esphome:
  name: pylontech-monitor
  friendly_name: Pylontech Monitor

esp32:
  board: wt32-eth01
  framework:
    type: esp-idf
    advanced:
      minimum_chip_revision: "3.1"

ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk_mode: GPIO0_IN
  phy_addr: 1
  power_pin: GPIO16

  # Optional manual IP
 # manual_ip:
 #   static_ip: 192.168.0.104
 #   gateway: 192.168.0.1
 #   subnet: 255.255.255.0
 #   dns1: 8.8.8.8

# Enable Home Assistant API
api:
  reboot_timeout: 15min
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

#wifi:
#  ssid: !secret wifi_ssid
#  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
#  ap:
#    ssid: "Wt-32 Fallback Hotspot"
#    password: "UlNPYb5tt4rO"

#captive_portal:

# --- Web Server ---
# This creates the web interface.
# We use version 3 for the modern UI with built-in Log Viewer.
web_server:
  port: 80
  version: 3

# --- UART Configuration ---
#wt32-eth01 uart1 is gpio17 and gpio05, maybe...

uart:
  - id: uart_bus
    tx_pin: GPIO17
    rx_pin: GPIO05
    baud_rate: 115200
    stop_bits: 1
    parity: NONE
    data_bits: 8
    rx_buffer_size: 4096 # Increased buffer to prevent data drops during large updates with large battery banks.  Without this default is 1500 which will fail on large banks
    debug:
      direction: BOTH
      dummy_receiver: true
      # Uncomment if needed for full insight into commands, disable normally due to the load on the ESP32
      sequence:
        - lambda: UARTDebug::log_string(direction, bytes);

# Enable logging (Required for the Web Server Log Viewer)
logger:
  level: DEBUG #DEBUG if you need detailed info
  baud_rate: 0 # Disable logging over USB Serial if you want to rely purely on WiFi logs

# Keep the robust external component to prevent "invalid bat_num" errors
# external_components:
#   - source: github://myhomeiot/esphome-components
#     components: [pylontech]

# --- Pylontech Component ---
pylontech:
  id: pylontech0
  uart_id: uart_bus
  # Adjust poling as desired
  update_interval: 1s

# --- Sensors ---
#Below is 3 batteries adjust as needed

sensor:
  - platform: pylontech
    battery: 1
    voltage:
      name: "Battery1 Voltage"
    current:
      name: "Battery1 Current"
    coulomb:
      name: "Battery1 SoC"
    temperature:
      name: "Battery1 Temp Average"
    voltage_low:
      name: "Battery1 Lowest Cell Voltage"
    voltage_high:
      name: "Battery1 Highest Cell Voltage"

  - platform: pylontech
    battery: 2
    voltage:
      name: "Battery2 Voltage"
    current:
      name: "Battery2 Current"
    coulomb:
      name: "Battery2 SoC"
    temperature:
      name: "Battery2 Temp Average"
    voltage_low:
      name: "Battery2 Lowest Cell Voltage"
    voltage_high:
      name: "Battery2 Highest Cell Voltage"

  - platform: pylontech
    battery: 3
    voltage:
      name: "Battery3 Voltage"
    current:
      name: "Battery3 Current"
    coulomb:
      name: "Battery3 SoC"
    temperature:
      name: "Battery3 Temp Average"
    voltage_low:
      name: "Battery3 Lowest Cell Voltage"
    voltage_high:
      name: "Battery3 Highest Cell Voltage"

# --- Web Terminal ---
# This creates a text box on the web page.
# Any text you type here is sent directly to the battery.
# text:
#   - platform: template
#     name: "Console Command"
#     icon: "mdi:console-line"
#     mode: text
#     optimistic: true # Required to handle input updates automatically
#     # When you press Enter in the web UI:
#     on_value:
#       then:
#         - logger.log: 
#             format: "Sending manual command: %s"
#             args: [ 'x.c_str()' ]
#         - uart.write:
#             id: uart_bus
#             # We append a newline (\n) automatically. 
#             # If the battery specifically needs \r, change this to: return x + "\r";
#             data: !lambda |
#               std::string s = x + "\n";
#               return std::vector<unsigned char>(s.begin(), s.end());

#This button in home assistant allows for an immediate update otherwise it will wait the duration
button:
  - platform: template
    name: "Force Update (PWR)"
    icon: "mdi:refresh"
    on_press:
      - logger.log: "Sending Force PWR command"
      - uart.write:
          id: uart_bus
          data: "pwr\n"

